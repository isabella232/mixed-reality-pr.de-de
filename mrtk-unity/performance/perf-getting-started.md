---
title: Leistung
description: Dokumentation zum Verstehen und Anpassen der Vorformanz im MRTK.
author: keveleigh
ms.author: kurtie
ms.date: 01/12/2021
keywords: Unity, HoloLens, HoloLens 2, Mixed Reality, Entwicklung, MRTK,
ms.openlocfilehash: 6c8e060af585d7994774ea0bb575b6e5172b9558
ms.sourcegitcommit: 912fa204ef79e9b973eab9b862846ba5ed5cd69f
ms.translationtype: MT
ms.contentlocale: de-DE
ms.lasthandoff: 07/16/2021
ms.locfileid: "114281769"
---
# <a name="performance"></a><span data-ttu-id="311aa-104">Leistung</span><span class="sxs-lookup"><span data-stu-id="311aa-104">Performance</span></span>

## <a name="getting-started"></a><span data-ttu-id="311aa-105">Erste Schritte</span><span class="sxs-lookup"><span data-stu-id="311aa-105">Getting started</span></span>

<span data-ttu-id="311aa-106">Die einfachste Möglichkeit, die Leistung zu rationalisieren, ist die Verwendung der Framerate oder der Anzahl, mit der Ihre Anwendung ein Bild pro Sekunde rendern kann.</span><span class="sxs-lookup"><span data-stu-id="311aa-106">The easiest way to rationalize performance is via framerate or how many times your application can render an image per second.</span></span> <span data-ttu-id="311aa-107">Es ist wichtig, die Zielframerate zu erreichen, wie von der Zielplattform (d. h.</span><span class="sxs-lookup"><span data-stu-id="311aa-107">It is important to meet the target framerate, as outlined by the platform being targeted (i.e</span></span> <span data-ttu-id="311aa-108">[Windows Mixed Reality,](/windows/mixed-reality/understanding-performance-for-mixed-reality) [Oculus](https://developer.oculus.com/documentation/pcsdk/latest/concepts/dg-performance-guidelines/)usw.).</span><span class="sxs-lookup"><span data-stu-id="311aa-108">[Windows Mixed Reality](/windows/mixed-reality/understanding-performance-for-mixed-reality), [Oculus](https://developer.oculus.com/documentation/pcsdk/latest/concepts/dg-performance-guidelines/), etc).</span></span> <span data-ttu-id="311aa-109">Bei HoloLens beträgt die Zielframerate beispielsweise 60 FPS.</span><span class="sxs-lookup"><span data-stu-id="311aa-109">For example, on HoloLens, the target framerate is 60 FPS.</span></span> <span data-ttu-id="311aa-110">Anwendungen mit niedriger Framerate können zu einer Verschlechterung der Benutzerfreundlichkeit führen, z. B. zur Stabilisierung von [Hologrammen,](../performance/hologram-stabilization.md)weltlicher Nachverfolgung, Handtracking und vielem mehr.</span><span class="sxs-lookup"><span data-stu-id="311aa-110">Low framerate applications can result in deteriorated user experiences such as worsened [hologram stabilization](../performance/hologram-stabilization.md), world tracking, hand tracking, and more.</span></span> <span data-ttu-id="311aa-111">Das Mixed Reality Toolkit bietet eine Vielzahl von Tools und Skripts, um Entwicklern das Nachverfolgen und Erzielen von Qualitätsframeraten zu erleichtern.</span><span class="sxs-lookup"><span data-stu-id="311aa-111">To help developers track and achieve quality framerate, the Mixed Reality Toolkit provides a variety of tools and scripts.</span></span>

### <a name="visual-profiler"></a><span data-ttu-id="311aa-112">Visueller Profiler</span><span class="sxs-lookup"><span data-stu-id="311aa-112">Visual profiler</span></span>

<span data-ttu-id="311aa-113">Um die Leistung über die Lebensdauer der Entwicklung hinweg kontinuierlich nachzuverfolgen, wird dringend empfohlen, beim Ausführen & Debuggen einer Anwendung immer ein Visuelles mit Framerate anzuzeigen.</span><span class="sxs-lookup"><span data-stu-id="311aa-113">To continuously track performance over the lifetime of development, it is highly recommended to always show a framerate visual while running & debugging an application.</span></span> <span data-ttu-id="311aa-114">Das Mixed Reality Toolkit stellt das [Diagnosetool Visual Profiler](../features/diagnostics/using-visual-profiler.md) bereit, das Echtzeitinformationen zum aktuellen FPS und zur Speicherauslastung in der Anwendungsansicht bereitstellt.</span><span class="sxs-lookup"><span data-stu-id="311aa-114">The Mixed Reality Toolkit provides the [Visual Profiler](../features/diagnostics/using-visual-profiler.md) diagnostic tool which gives real-time information about the current FPS and memory usage in application view.</span></span> <span data-ttu-id="311aa-115">Der Visual Profiler kann über das [Diagnosesystem Einstellungen](../features/diagnostics/diagnostics-system-getting-started.md) unter dem [MRTK Profiles Inspector](../configuration/mixed-reality-configuration-guide.md)konfiguriert werden.</span><span class="sxs-lookup"><span data-stu-id="311aa-115">The Visual Profiler can be configured via the [Diagnostics System Settings](../features/diagnostics/diagnostics-system-getting-started.md) under the [MRTK Profiles Inspector](../configuration/mixed-reality-configuration-guide.md).</span></span>

<span data-ttu-id="311aa-116">Darüber hinaus ist es besonders wichtig, den Visual Profiler zu verwenden, um die Framerate nachzuverfolgen, wenn er auf dem Gerät ausgeführt wird, anstatt im Unity-Editor oder in einem Emulator ausgeführt zu werden.</span><span class="sxs-lookup"><span data-stu-id="311aa-116">Furthermore, it is particularly important to utilize the Visual Profiler to track framerate when running on the device as opposed to running in Unity editor or an emulator.</span></span> <span data-ttu-id="311aa-117">Die genauesten Leistungsergebnisse werden bei der Ausführung auf dem Gerät mit [Releasekonfigurationsbuilds](/visualstudio/debugger/how-to-set-debug-and-release-configurations?preserve-view=true&view=vs-2019)dargestellt.</span><span class="sxs-lookup"><span data-stu-id="311aa-117">The most accurate performance results will be depicted when running on the device with [Release configuration builds](/visualstudio/debugger/how-to-set-debug-and-release-configurations?preserve-view=true&view=vs-2019).</span></span>

> [!NOTE]
> <span data-ttu-id="311aa-118">Wenn Sie für Windows Mixed Reality erstellen, stellen Sie mit [MASTER-Konfigurationsbuilds](/windows/mixed-reality/exporting-and-building-a-unity-visual-studio-solution#building_and_deploying_a_unity_visual_studio_solution) bereit.</span><span class="sxs-lookup"><span data-stu-id="311aa-118">If building for Windows Mixed Reality, deploy with [MASTER configuration builds](/windows/mixed-reality/exporting-and-building-a-unity-visual-studio-solution#building_and_deploying_a_unity_visual_studio_solution)</span></span>

![Grafische Profiler-Schnittstelle](../features/images/Diagnostics/VisualProfiler.png)

### <a name="optimize-window"></a><span data-ttu-id="311aa-120">Optimierungsfenster</span><span class="sxs-lookup"><span data-stu-id="311aa-120">Optimize window</span></span>

<span data-ttu-id="311aa-121">Das [MRTK-Fenster "Optimieren"](../features/tools/optimize-window.md) bietet Informationen und Automatisierungstools, mit denen Mixed Reality-Entwickler ihre Umgebung für die leistungsfähigsten Ergebnisse einrichten und potenzielle Engpässe in ihrer Szene & Ressourcen identifizieren können.</span><span class="sxs-lookup"><span data-stu-id="311aa-121">The [MRTK Optimize Window](../features/tools/optimize-window.md) offers information and automation tools to help mixed reality developers set up their environment for the best performing results and identify potential bottlenecks in their scene & assets.</span></span> <span data-ttu-id="311aa-122">Bestimmte Schlüsselkonfigurationen in Unity können dazu beitragen, wesentlich optimierte Ergebnisse für Mixed Reality-Projekte zu liefern.</span><span class="sxs-lookup"><span data-stu-id="311aa-122">Certain key configurations in Unity can help deliver substantially more optimized results for mixed reality projects.</span></span>

<span data-ttu-id="311aa-123">Im Allgemeinen umfassen diese Einstellungen Renderingkonfigurationen, die ideal für Mixed Reality sind.</span><span class="sxs-lookup"><span data-stu-id="311aa-123">Generally, these settings involve rendering configurations that are ideal for mixed reality.</span></span> <span data-ttu-id="311aa-124">Mixed Reality-Anwendungen sind im Vergleich zur herkömmlichen 3D-Grafikentwicklung einzigartig, da es zwei Bildschirme gibt (d. h.</span><span class="sxs-lookup"><span data-stu-id="311aa-124">Mixed reality applications are unique compared to traditional 3D graphics development in that there are two screens (i.e</span></span> <span data-ttu-id="311aa-125">zwei Augen), die für die gesamte Szene gerendert werden sollen.</span><span class="sxs-lookup"><span data-stu-id="311aa-125">two eyes) to render for the entire scene.</span></span>

<span data-ttu-id="311aa-126">Die unten aufgeführten empfohlenen Einstellungen können mithilfe des MRTK-Optimierungsfensters automatisch in einem Unity-Projekt konfiguriert werden.</span><span class="sxs-lookup"><span data-stu-id="311aa-126">The recommended settings referenced below can be auto-configured in a Unity project by leveraging the MRTK Optimize Window.</span></span>

![MRTK Optimize Window Einstellungen](../features/images/performance/OptimizeWindow_Settings.png)

### <a name="unity-profiler"></a><span data-ttu-id="311aa-128">Unity Profiler</span><span class="sxs-lookup"><span data-stu-id="311aa-128">Unity Profiler</span></span>

<span data-ttu-id="311aa-129">Der [Unity Profiler](https://docs.unity3d.com/Manual/ProfilerWindow.html) ist ein nützliches Tool, um Details zur Anwendungsleistung auf Frame-by-Frame-Ebene zu untersuchen.</span><span class="sxs-lookup"><span data-stu-id="311aa-129">The [Unity Profiler](https://docs.unity3d.com/Manual/ProfilerWindow.html) is a useful tool to investigate details of application performance at a frame-by-frame level.</span></span>

#### <a name="time-spent-on-the-cpu"></a><span data-ttu-id="311aa-130">Für die CPU aufgewendete Zeit</span><span class="sxs-lookup"><span data-stu-id="311aa-130">Time spent on the CPU</span></span>

![Unity Profiler-Beispiel Graph](../features/images/performance/UnityProfilerGraph.png)

<span data-ttu-id="311aa-132">Um komfortable Bildfrequenzen (in der Regel 60 Frames pro Sekunde) zu gewährleisten, müssen Anwendungen eine maximale Framezeit von 16,6 Millisekunden CPU-Zeit erreichen.</span><span class="sxs-lookup"><span data-stu-id="311aa-132">To maintain comfortable frame rates (typically 60 frames per second), applications need to achieve a maximum frame time of 16.6 milliseconds of CPU time.</span></span> <span data-ttu-id="311aa-133">Um die Kosten der MRTK-Funktionalität zu ermitteln, enthält das Microsoft Mixed Reality Toolkit Marker für Codepfade der inneren Schleife (pro Frame).</span><span class="sxs-lookup"><span data-stu-id="311aa-133">To help identify the cost of MRTK functionality, the Microsoft Mixed Reality Toolkit contains a markers for inner loop (per frame) code paths.</span></span> <span data-ttu-id="311aa-134">Diese Marker verwenden das folgende Format, um das Verständnis der jeweiligen verwendeten Funktionalität zu erleichtern:</span><span class="sxs-lookup"><span data-stu-id="311aa-134">These markers use the following format, to assist in understanding the specific functionality being utilized:</span></span>

```
[MRTK] className.methodName
```

> [!Note]
> <span data-ttu-id="311aa-135">Nach dem Methodennamen können weitere Daten vorhanden sein.</span><span class="sxs-lookup"><span data-stu-id="311aa-135">There may be additional data following the method name.</span></span> <span data-ttu-id="311aa-136">Dies wird verwendet, um bedingt ausgeführte, potenziell teure Funktionen zu identifizieren, die durch kleine Änderungen am Anwendungscode vermieden werden können.</span><span class="sxs-lookup"><span data-stu-id="311aa-136">This is used to identify conditionally executed, potentially expensive functionality that may be avoided by small changes to application code.</span></span>

![Beispielhierarchie für Unity Profiler](../features/images/performance/UnityProfilerHierarchy.png)

<span data-ttu-id="311aa-138">In diesem Beispiel wurde die Hierarchie erweitert, um zu zeigen, dass die UpdateHandData-Methode der WindowsMixedRealityArticulatedHand-Klasse während des analysierten Frames 0,44 ms CPU-Zeit verbraucht.</span><span class="sxs-lookup"><span data-stu-id="311aa-138">In this example, the hierarchy has been expanded to show that the UpdateHandData method of WindowsMixedRealityArticulatedHand class is consuming 0.44 ms of CPU time during the frame being analyzed.</span></span> <span data-ttu-id="311aa-139">Anhand dieser Daten kann ermittelt werden, ob ein Leistungsproblem mit Anwendungscode oder von einem anderen System aus zusammenhängt.</span><span class="sxs-lookup"><span data-stu-id="311aa-139">This data can be used to help determine if a performance issue is related to application code or from elsewhere in the system.</span></span>

<span data-ttu-id="311aa-140">Es wird dringend empfohlen, Anwendungscode auf ähnliche Weise zu instrumentieren.</span><span class="sxs-lookup"><span data-stu-id="311aa-140">It is highly recommended that developers instrument application code in a similar fashion.</span></span> <span data-ttu-id="311aa-141">Der Hauptfokus für die Instrumentierung von Anwendungscode liegt innerhalb von Ereignishandlern, da diese Methoden der MRTK-Updateschleife in Rechnung gestellt werden, wenn Ereignisse ausgelöst werden.</span><span class="sxs-lookup"><span data-stu-id="311aa-141">Primary areas of focus for application code instrumentation is within event handlers as these methods are charged to the MRTK update loop as events are raised.</span></span> <span data-ttu-id="311aa-142">Hohe Framezeiten innerhalb der MRTK-Updateschleife können auf teuren Code in Ereignishandlermethoden hindeuten.</span><span class="sxs-lookup"><span data-stu-id="311aa-142">High frame times within the MRTK update loop can be indicative of expensive code in event handler methods.</span></span>

## <a name="recommended-settings-for-unity"></a><span data-ttu-id="311aa-143">Empfohlene Einstellungen für Unity</span><span class="sxs-lookup"><span data-stu-id="311aa-143">Recommended settings for Unity</span></span>

### <a name="single-pass-instanced-rendering"></a><span data-ttu-id="311aa-144">rendern von Single-Pass Instanced</span><span class="sxs-lookup"><span data-stu-id="311aa-144">Single-Pass Instanced rendering</span></span>

<span data-ttu-id="311aa-145">Die Standardrenderingkonfiguration für XR in Unity ist [Multipass.](https://docs.unity3d.com/ScriptReference/StereoRenderingPath.MultiPass.html)</span><span class="sxs-lookup"><span data-stu-id="311aa-145">The default rendering configuration for XR in Unity is [Multi-pass](https://docs.unity3d.com/ScriptReference/StereoRenderingPath.MultiPass.html).</span></span> <span data-ttu-id="311aa-146">Diese Einstellung weist Unity an, die gesamte Renderpipeline zweimal auszuführen, einmal für jedes Auge.</span><span class="sxs-lookup"><span data-stu-id="311aa-146">This setting instructs Unity to execute the entire render pipeline twice, once for each eye.</span></span> <span data-ttu-id="311aa-147">Dies kann optimiert werden, indem Sie stattdessen [Single Pass Instanced Rendering](https://docs.unity3d.com/Manual/SinglePassInstancing.html) auswählen.</span><span class="sxs-lookup"><span data-stu-id="311aa-147">This can be optimized by selecting [Single Pass Instanced rendering](https://docs.unity3d.com/Manual/SinglePassInstancing.html) instead.</span></span> <span data-ttu-id="311aa-148">Diese Konfiguration nutzt [Renderzielarrays,](https://en.wikipedia.org/wiki/Multiple_Render_Targets) um einen einzelnen Zeichnen-Aufruf ausführen zu können, der für jedes Auge das entsprechende [Renderziel](https://en.wikipedia.org/wiki/Render_Target) eingibt.</span><span class="sxs-lookup"><span data-stu-id="311aa-148">This configuration leverages [render target arrays](https://en.wikipedia.org/wiki/Multiple_Render_Targets) to be able to perform a single draw call that instances into the appropriate [render target](https://en.wikipedia.org/wiki/Render_Target) for each eye.</span></span> <span data-ttu-id="311aa-149">Darüber hinaus ermöglicht dieser Modus das Gesamte Rendering in einer einzelnen Ausführung der Renderingpipeline.</span><span class="sxs-lookup"><span data-stu-id="311aa-149">Furthermore, this mode allows all rendering to be done in a single execution of the rendering pipeline.</span></span> <span data-ttu-id="311aa-150">Daher kann die Auswahl des Single Pass Instanced-Renderings als Renderingpfad für eine Mixed Reality-Anwendung [erhebliche Zeit auf der CPU-& GPU sparen](https://blogs.unity3d.com/2017/11/21/how-to-maximize-ar-and-vr-performance-with-advanced-stereo-rendering/) und ist die empfohlene Renderingkonfiguration.</span><span class="sxs-lookup"><span data-stu-id="311aa-150">Thus, selecting Single Pass Instanced rendering as the rendering path for a mixed reality application can [save substantial time on both the CPU & GPU](https://blogs.unity3d.com/2017/11/21/how-to-maximize-ar-and-vr-performance-with-advanced-stereo-rendering/) and is the recommended rendering configuration.</span></span>

<span data-ttu-id="311aa-151">Um jedoch einen einzelnen Zeichnen-Aufruf für jedes Gitternetz für jedes Auge auszugeben, muss die [GPU-Instanziierung](https://docs.unity3d.com/Manual/GPUInstancing.html) von allen Shadern unterstützt werden.</span><span class="sxs-lookup"><span data-stu-id="311aa-151">However, in order to issue a single draw call for each mesh to each eye, [GPU instancing](https://docs.unity3d.com/Manual/GPUInstancing.html) must be supported by all shaders.</span></span> <span data-ttu-id="311aa-152">Die Instanziierung ermöglicht der GPU das Multiplex-Zeichnen von Aufrufen über beide Augen hinweg.</span><span class="sxs-lookup"><span data-stu-id="311aa-152">Instancing allows the GPU to multiplex draw calls across both eyes.</span></span> <span data-ttu-id="311aa-153">Integrierte Unity-Shader sowie der [MRTK Standard-Shader](../features/rendering/mrtk-standard-shader.md) enthalten standardmäßig die erforderlichen Instanziierungsanweisungen im Shadercode.</span><span class="sxs-lookup"><span data-stu-id="311aa-153">Unity built-in shaders as well as the [MRTK Standard shader](../features/rendering/mrtk-standard-shader.md) by default contain the necessary instancing instructions in shader code.</span></span> <span data-ttu-id="311aa-154">Wenn Sie jedoch benutzerdefinierte Shader für Unity schreiben, müssen diese Shader möglicherweise aktualisiert werden, um single pass Instanced-Rendering zu unterstützen.</span><span class="sxs-lookup"><span data-stu-id="311aa-154">If writing custom shaders though for Unity, these shaders may need to be updated to support Single Pass Instanced rendering.</span></span>

#### <a name="example-code-for-custom-shader"></a>[<span data-ttu-id="311aa-155">Beispielcode für benutzerdefinierten Shader</span><span class="sxs-lookup"><span data-stu-id="311aa-155">Example Code for Custom Shader</span></span>](https://docs.unity3d.com/Manual/SinglePassInstancing.html)

```
struct appdata
{
    float4 vertex : POSITION;
    float2 uv : TEXCOORD0;

    UNITY_VERTEX_INPUT_INSTANCE_ID //Insert
};

struct v2f
{
    float2 uv : TEXCOORD0;
    float4 vertex : SV_POSITION;

    UNITY_VERTEX_OUTPUT_STEREO //Insert
};

v2f vert (appdata v)
{
    v2f o;

    UNITY_SETUP_INSTANCE_ID(v); //Insert
    UNITY_INITIALIZE_OUTPUT(v2f, o); //Insert
    UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o); //Insert

    o.vertex = UnityObjectToClipPos(v.vertex);

    o.uv = v.uv;

    return o;
}
```

### <a name="quality-settings"></a><span data-ttu-id="311aa-156">Qualitätseinstellungen</span><span class="sxs-lookup"><span data-stu-id="311aa-156">Quality settings</span></span>

<span data-ttu-id="311aa-157">Unity bietet [Voreinstellungen zum Steuern](https://docs.unity3d.com/Manual/class-QualitySettings.html) der Renderingqualität für jeden Plattformendpunkt.</span><span class="sxs-lookup"><span data-stu-id="311aa-157">Unity provides [presets to control quality](https://docs.unity3d.com/Manual/class-QualitySettings.html) of rendering for each platform endpoint.</span></span> <span data-ttu-id="311aa-158">Diese Voreinstellungen steuern, welche grafischen Features aktiviert werden können, z. B. Schatten, Antialiasing, globale Beleuchtung und vieles mehr.</span><span class="sxs-lookup"><span data-stu-id="311aa-158">These presets control what graphical features can be enabled such as shadows, anti-aliasing, global illumination, and more.</span></span> <span data-ttu-id="311aa-159">Es wird empfohlen, diese Einstellungen zu verringern und die Anzahl von Berechnungen zu optimieren, die während des Renderings durchgeführt werden.</span><span class="sxs-lookup"><span data-stu-id="311aa-159">It is recommended to lower these settings and optimize the number of calculations performed during rendering.</span></span>

<span data-ttu-id="311aa-160">*Schritt 1:* Aktualisieren von Mixed Reality-Unity-Projekten für die Verwendung der Einstellung *"Niedrige Qualitätsstufe"*</span><span class="sxs-lookup"><span data-stu-id="311aa-160">*Step 1:* Update mixed reality Unity projects to use the *Low Quality* level setting</span></span>  
<span data-ttu-id="311aa-161">**Bearbeiten**  >  **Project Einstellungen**, und wählen Sie dann die Kategorie **Qualität** aus, > Wählen Sie *niedrige Qualität* für die UWP-Plattform aus.</span><span class="sxs-lookup"><span data-stu-id="311aa-161">**Edit** > **Project Settings**, then select the **Quality** category >  Select *Low Quality* for the UWP Platform</span></span>

<span data-ttu-id="311aa-162">*Schritt 2:* Deaktivieren Sie für jede [Unity-Szenendatei "Global Unity" in Echtzeit.](https://docs.unity3d.com/Manual/LightMode-Realtime.html)</span><span class="sxs-lookup"><span data-stu-id="311aa-162">*Step 2:* For every Unity scene file, disable [real-time Global Illumination](https://docs.unity3d.com/Manual/LightMode-Realtime.html)</span></span>  
<span data-ttu-id="311aa-163">**Fenster**  >  **Rendering**  >  **Beleuchtung Einstellungen**  >  [Deaktivieren Der *globale Echtzeitausgehungs-Kontrollkästchen*](https://docs.unity3d.com/Manual/GlobalIllumination.html)</span><span class="sxs-lookup"><span data-stu-id="311aa-163">**Window** > **Rendering** > **Lighting Settings** > [Uncheck *Real-time Global Illumination*](https://docs.unity3d.com/Manual/GlobalIllumination.html)</span></span>

### <a name="depth-buffer-sharing-hololens"></a><span data-ttu-id="311aa-164">Tiefenpufferfreigabe (HoloLens)</span><span class="sxs-lookup"><span data-stu-id="311aa-164">Depth buffer sharing (HoloLens)</span></span>

<span data-ttu-id="311aa-165">Bei der Entwicklung für die Windows Mixed Reality-Plattform und insbesondere für HoloLens kann die Aktivierung *der Tiefenpufferfreigabe* unter *XR Einstellungen* bei der [Hologrammstabilität](../performance/hologram-stabilization.md)helfen.</span><span class="sxs-lookup"><span data-stu-id="311aa-165">If developing for the Windows Mixed Reality platform and in particular HoloLens, enabling *Depth Buffer Sharing* under *XR Settings* can help with [hologram stabilization](../performance/hologram-stabilization.md).</span></span> <span data-ttu-id="311aa-166">Die Verarbeitung des Tiefenpuffers kann jedoch Leistungskosten verursachen, insbesondere bei Verwendung des [24-Bit-Tiefenformats.](https://docs.unity3d.com/ScriptReference/PlayerSettings.VRWindowsMixedReality-depthBufferFormat.html)</span><span class="sxs-lookup"><span data-stu-id="311aa-166">However, processing of the depth buffer can incur a performance cost, particularly if using [24-bit depth format](https://docs.unity3d.com/ScriptReference/PlayerSettings.VRWindowsMixedReality-depthBufferFormat.html).</span></span> <span data-ttu-id="311aa-167">Daher wird *dringend empfohlen,* den Tiefenpuffer auf 16-Bit-Genauigkeit zu konfigurieren.</span><span class="sxs-lookup"><span data-stu-id="311aa-167">Thus, it is *highly recommended* to configure the depth buffer to 16-bit precision.</span></span>

<span data-ttu-id="311aa-168">Wenn [Z-Fighting](https://en.wikipedia.org/wiki/Z-fighting) aufgrund des niedrigeren Bitformats auftritt, vergewissern Sie sich, dass die [entfernte Clipebene](https://docs.unity3d.com/Manual/class-Camera.html) aller Kameras auf den niedrigsten möglichen Wert für die Anwendung festgelegt ist.</span><span class="sxs-lookup"><span data-stu-id="311aa-168">If [z-fighting](https://en.wikipedia.org/wiki/Z-fighting) occurs due to the lower bit format, confirm the [far clip plane](https://docs.unity3d.com/Manual/class-Camera.html) of all cameras is set to the lowest possible value for the application.</span></span> <span data-ttu-id="311aa-169">Unity legt standardmäßig eine entfernte Clipebene von 1.000 m fest.</span><span class="sxs-lookup"><span data-stu-id="311aa-169">Unity by default sets a far clip plane of 1000m.</span></span> <span data-ttu-id="311aa-170">Auf HoloLens ist eine weit entfernte Clipebene von 50 m in der Regel für die meisten Anwendungsszenarien mehr als ausreichend.</span><span class="sxs-lookup"><span data-stu-id="311aa-170">On HoloLens, a far clip plane of 50m is generally more than enough for most application scenarios.</span></span>

> [!NOTE]
> <span data-ttu-id="311aa-171">Bei Verwendung des *16-Bit-Tiefenformats* funktionieren die erforderlichen Auswirkungen des Schablonenpuffers nicht, da Unity in dieser Einstellung [keinen Schablonenpuffer erstellt.](https://docs.unity3d.com/ScriptReference/RenderTexture-depth.html)</span><span class="sxs-lookup"><span data-stu-id="311aa-171">If using *16-bit depth format*, stencil buffer required effects will not work because [Unity does not create a stencil buffer](https://docs.unity3d.com/ScriptReference/RenderTexture-depth.html) in this setting.</span></span> <span data-ttu-id="311aa-172">Wenn Sie umgekehrt das *24-Bit-Tiefenformat* auswählen, wird in der Regel ein 8-Bit-Schablonenpuffer erstellt, sofern dies auf der Endpunktgrafikplattform anwendbar ist.</span><span class="sxs-lookup"><span data-stu-id="311aa-172">Selecting *24-bit depth format* conversely will generally create an 8-bit stencil buffer, if applicable on the endpoint graphics platform.</span></span>
>
> <span data-ttu-id="311aa-173">Wenn Sie eine [Mask-Komponente](https://docs.unity3d.com/Manual/script-Mask.html) verwenden, die den Schablonenpuffer erfordert, erwägen Sie stattdessen die Verwendung von [RectMask2D,](https://docs.unity3d.com/Manual/script-RectMask2D.html) die den Schablonenpuffer nicht benötigt und daher in Verbindung mit einem *16-Bit-Tiefenformat* verwendet werden kann.</span><span class="sxs-lookup"><span data-stu-id="311aa-173">If using a [Mask component](https://docs.unity3d.com/Manual/script-Mask.html) which requires the stencil buffer, consider using [RectMask2D](https://docs.unity3d.com/Manual/script-RectMask2D.html) instead, which does not require the stencil buffer and thus can be used in conjunction with a *16-bit depth format*.</span></span>

> [!NOTE]
> <span data-ttu-id="311aa-174">Um schnell zu bestimmen, welche Objekte in einer Szene nicht visuell in den Tiefenpuffer schreiben, können Sie das [ *Hilfsprogramm Tiefenpuffer rendern*](../configuration/mixed-reality-configuration-guide.md#editor-utilities) unter dem *Editor-Einstellungen* im MRTK-Konfigurationsprofil verwenden.</span><span class="sxs-lookup"><span data-stu-id="311aa-174">To quickly determine which objects in a scene do not write to the depth buffer visually, one can use the [*Render Depth Buffer* utility](../configuration/mixed-reality-configuration-guide.md#editor-utilities) under the *Editor Settings* in the MRTK Configuration profile.</span></span>

### <a name="optimize-mesh-data"></a><span data-ttu-id="311aa-175">Optimieren von Meshdaten</span><span class="sxs-lookup"><span data-stu-id="311aa-175">Optimize Mesh Data</span></span>

<span data-ttu-id="311aa-176">Mit den Einstellungen zum Optimieren von [Gitternetzdaten](https://docs.unity3d.com/ScriptReference/PlayerSettings-stripUnusedMeshComponents.html) wird versucht, nicht verwendete Scheitelpunktattribute in Ihrer Anwendung zu entfernen.</span><span class="sxs-lookup"><span data-stu-id="311aa-176">The [Optimize Mesh Data](https://docs.unity3d.com/ScriptReference/PlayerSettings-stripUnusedMeshComponents.html) settings tries to remove unused vertex attributes within your application.</span></span> <span data-ttu-id="311aa-177">Die Einstellung führt dies durch Ausführung über jeden Shaderdurchlauf in jedem Material aus, das sich in jedem Gitternetz im Build befindet.</span><span class="sxs-lookup"><span data-stu-id="311aa-177">The setting performs this by running over every shader pass in every material that is on every mesh in the build.</span></span> <span data-ttu-id="311aa-178">Dies ist gut für die Größe der Spieldaten und die Laufzeitleistung geeignet, kann aber die Buildzeiten erheblich beeinträchtigen.</span><span class="sxs-lookup"><span data-stu-id="311aa-178">This is good for game data size and runtime performance but can drastically hinder build times.</span></span>

<span data-ttu-id="311aa-179">Es wird empfohlen, diese Einstellung während der Entwicklung zu deaktivieren und während der Erstellung des Masterbuilds erneut zu aktivieren.</span><span class="sxs-lookup"><span data-stu-id="311aa-179">It is recommended to disable this setting during development and re-enable during "Master" build creation.</span></span> <span data-ttu-id="311aa-180">Die Einstellung finden **Sie** unter Edit  >  **Project Einstellungen**  >  **Player**  >  **Other Einstellungen** Optimize Mesh  >  **Data**.</span><span class="sxs-lookup"><span data-stu-id="311aa-180">The setting can be found under **Edit** > **Project Settings** > **Player** > **Other Settings** > **Optimize Mesh Data**.</span></span>

## <a name="general-recommendations"></a><span data-ttu-id="311aa-181">Allgemeine Empfehlungen</span><span class="sxs-lookup"><span data-stu-id="311aa-181">General recommendations</span></span>

<span data-ttu-id="311aa-182">Die Leistung kann eine mehrdeutige und sich ständig ändernde Herausforderung für Mixed Reality-Entwickler sein, und das Wissensspektrum zur Rationalisierung der Leistung ist sehr umfangreich.</span><span class="sxs-lookup"><span data-stu-id="311aa-182">Performance can be an ambiguous and constantly changing challenge for mixed reality developers and the spectrum of knowledge to rationalize performance is vast.</span></span> <span data-ttu-id="311aa-183">Es gibt jedoch einige allgemeine Empfehlungen, um zu verstehen, wie die Leistung einer Anwendung an den Ansatz geht.</span><span class="sxs-lookup"><span data-stu-id="311aa-183">There are some general recommendations for understanding how to approach performance for an application though.</span></span>

<span data-ttu-id="311aa-184">Es ist hilfreich, die Ausführung einer Anwendung in die Teile zu vereinfachen, die auf der *CPU* oder *GPU* ausgeführt werden, und so zu ermitteln, ob eine App durch eine der komponentengebundenen Komponenten gebunden ist.</span><span class="sxs-lookup"><span data-stu-id="311aa-184">It is useful to simplify the execution of an application into the pieces that run on the *CPU* or the *GPU* and thus identify whether an app is bounded by either component.</span></span>  <span data-ttu-id="311aa-185">Es kann Engpässe geben, die sich sowohl auf Verarbeitungseinheiten als auch auf einige eindeutige Szenarien erstrecken, die sorgfältig untersucht werden müssen.</span><span class="sxs-lookup"><span data-stu-id="311aa-185">There can be bottlenecks that span both processing units and some unique scenarios that have to be carefully investigated.</span></span> <span data-ttu-id="311aa-186">Für die ersten Schritte ist es jedoch gut zu verstehen, wo eine Anwendung für die meiste Zeit ausgeführt wird.</span><span class="sxs-lookup"><span data-stu-id="311aa-186">However, for getting started, it is good to grasp where an application is executing for the most amount of time.</span></span>

### <a name="gpu-bounded"></a><span data-ttu-id="311aa-187">GPU-gebunden</span><span class="sxs-lookup"><span data-stu-id="311aa-187">GPU bounded</span></span>

<span data-ttu-id="311aa-188">Da die meisten Plattformen für Mixed Reality-Anwendungen [stereokopiertes Rendering](https://en.wikipedia.org/wiki/Stereoscopy)verwenden, ist es aufgrund der Art des Renderns eines "doppelweiten" Bildschirms sehr häufig gpugebunden.</span><span class="sxs-lookup"><span data-stu-id="311aa-188">Since most platforms for mixed reality applications are utilizing [stereoscopic rendering](https://en.wikipedia.org/wiki/Stereoscopy), it is very common to be GPU-bounded due to the nature of rendering a "double-wide" screen.</span></span> <span data-ttu-id="311aa-189">Futhermore: Mobile Mixed Reality-Plattformen wie HoloLens oder Oculus Quest werden durch cpu-& GPU-Verarbeitungsleistung der mobilen Klasse eingeschränkt.</span><span class="sxs-lookup"><span data-stu-id="311aa-189">Futhermore, mobile mixed reality platforms such as HoloLens or Oculus Quest will be limited by mobile-class CPU & GPU processing power.</span></span>

<span data-ttu-id="311aa-190">Wenn Sie sich auf die GPU konzentrieren, gibt es im Allgemeinen zwei wichtige Phasen, in denen eine Anwendung jeden Frame abschließen muss.</span><span class="sxs-lookup"><span data-stu-id="311aa-190">When focusing on the GPU, there are generally two important stages that an application must complete every frame.</span></span>

1. <span data-ttu-id="311aa-191">Ausführen des [Vertex-Shaders](https://en.wikipedia.org/wiki/Shader#Vertex_shaders)</span><span class="sxs-lookup"><span data-stu-id="311aa-191">Execute the [vertex shader](https://en.wikipedia.org/wiki/Shader#Vertex_shaders)</span></span>
2. <span data-ttu-id="311aa-192">Führen Sie den [Pixelshader](https://en.wikipedia.org/wiki/Shader#Pixel_shaders) (auch als Fragment-Shader bezeichnet) aus.</span><span class="sxs-lookup"><span data-stu-id="311aa-192">Execute the [pixel shader](https://en.wikipedia.org/wiki/Shader#Pixel_shaders) (also known as the fragment shader)</span></span>

<span data-ttu-id="311aa-193">Ohne einen tieferen Einblick in das komplexe Feld der Computergrafiken & [Renderingpipelines](https://en.wikipedia.org/wiki/Graphics_pipeline)ist jede Shaderphase ein Programm, das auf der GPU ausgeführt wird, um Folgendes zu erzeugen.</span><span class="sxs-lookup"><span data-stu-id="311aa-193">Without deep diving into the complex field of computer graphics & [rendering pipelines](https://en.wikipedia.org/wiki/Graphics_pipeline), each shader stage is a program that runs on the GPU to produce the following.</span></span>

1. <span data-ttu-id="311aa-194">Vertex-Shader transformieren Netzvertices in Koordinaten im Bildschirmbereich (d. h.</span><span class="sxs-lookup"><span data-stu-id="311aa-194">Vertex shaders transform mesh vertices to coordinates in screen-space (i.e</span></span> <span data-ttu-id="311aa-195">Pro Scheitelpunkt ausgeführter Code)</span><span class="sxs-lookup"><span data-stu-id="311aa-195">code executed per vertex)</span></span>
2. <span data-ttu-id="311aa-196">Pixel-Shader berechnen die Farbe, die für ein bestimmtes Pixel- und Gitternetzfragment gezeichnet werden soll (d.h.</span><span class="sxs-lookup"><span data-stu-id="311aa-196">Pixel shaders calculate the color to draw for a given pixel and mesh fragment (i.e</span></span> <span data-ttu-id="311aa-197">Codeausführung pro Pixel)</span><span class="sxs-lookup"><span data-stu-id="311aa-197">code execute per pixel)</span></span>

<span data-ttu-id="311aa-198">Im Hinblick auf die Leistungsoptimierung ist es in der Regel schwieriger, sich auf die Optimierung der Vorgänge im Pixel-Shader zu konzentrieren.</span><span class="sxs-lookup"><span data-stu-id="311aa-198">In regards to performance tuning, it is usually more fruitful to focus on optimizing the operations in the pixel shader.</span></span> <span data-ttu-id="311aa-199">Eine Anwendung muss möglicherweise nur einen Würfel zeichnen, der nur 8 Scheitelpunkte hat.</span><span class="sxs-lookup"><span data-stu-id="311aa-199">An application may only need to draw a cube which will just be 8 vertices.</span></span> <span data-ttu-id="311aa-200">Der Bildschirmbereich, den der Cube belegt, liegt jedoch wahrscheinlich in der Größenordnung von Millionen von Pixeln.</span><span class="sxs-lookup"><span data-stu-id="311aa-200">However, the screen space that cube occupies is likely on the order of millions of pixels.</span></span> <span data-ttu-id="311aa-201">Daher kann die Reduzierung von Shadercode um z. B. 10 Vorgänge erheblich mehr Arbeit sparen, wenn der Pixel-Shader reduziert wird als der Vertex-Shader.</span><span class="sxs-lookup"><span data-stu-id="311aa-201">Thus, reducing shader code by say 10 operations can save significantly more work if reduced on the pixel shader than the vertex shader.</span></span>

<span data-ttu-id="311aa-202">Dies ist einer der Hauptgründe für die Nutzung des [MRTK Standard-Shaders,](../features/rendering/mrtk-standard-shader.md) da dieser Shader im Allgemeinen viel weniger Anweisungen pro Pixel & Scheitelpunkt als der Unity Standard-Shader ausführen und gleichzeitig vergleichbare ergebnisse erzielen kann.</span><span class="sxs-lookup"><span data-stu-id="311aa-202">This is one of the primary reasons for leveraging the [MRTK Standard shader](../features/rendering/mrtk-standard-shader.md) as this shader generally executes many less instructions per pixel & vertex than the Unity Standard shader while achieving comparable aesthetic results.</span></span>

|    <span data-ttu-id="311aa-203">CPU-Optimierungen</span><span class="sxs-lookup"><span data-stu-id="311aa-203">CPU Optimizations</span></span>      |             <span data-ttu-id="311aa-204">GPU-Optimierungen</span><span class="sxs-lookup"><span data-stu-id="311aa-204">GPU Optimizations</span></span>              |
|---------------------------|--------------------------------------------|
| <span data-ttu-id="311aa-205">Logik der App-Simulation</span><span class="sxs-lookup"><span data-stu-id="311aa-205">App simulation logic</span></span>      | <span data-ttu-id="311aa-206">Renderingvorgänge</span><span class="sxs-lookup"><span data-stu-id="311aa-206">Rendering operations</span></span> |
| <span data-ttu-id="311aa-207">Vereinfachen der Physik</span><span class="sxs-lookup"><span data-stu-id="311aa-207">Simplify Physics</span></span>          | <span data-ttu-id="311aa-208">Reduzieren von Beleuchtungsberechnungen</span><span class="sxs-lookup"><span data-stu-id="311aa-208">Reduce lighting calculations</span></span> |
| <span data-ttu-id="311aa-209">Vereinfachen von Animationen</span><span class="sxs-lookup"><span data-stu-id="311aa-209">Simplify Animations</span></span>       | <span data-ttu-id="311aa-210">Reduzieren der Polygonanzahl & Anzahl von ziehbaren Objekten</span><span class="sxs-lookup"><span data-stu-id="311aa-210">Reduce polygon count & # of drawable objects</span></span> |
| <span data-ttu-id="311aa-211">Verwalten der Garbage Collection</span><span class="sxs-lookup"><span data-stu-id="311aa-211">Manage Garbage Collection</span></span> | <span data-ttu-id="311aa-212">Reduzieren der Anzahl von transparenten Objekten</span><span class="sxs-lookup"><span data-stu-id="311aa-212">Reduce # of transparent objects</span></span> |
| <span data-ttu-id="311aa-213">Cacheverweise</span><span class="sxs-lookup"><span data-stu-id="311aa-213">Cache References</span></span>          | <span data-ttu-id="311aa-214">Vermeiden von Nachverarbeitungs-/Vollbildeffekten</span><span class="sxs-lookup"><span data-stu-id="311aa-214">Avoid post-processing/full-screen effects</span></span>  |

### <a name="draw-call-instancing"></a><span data-ttu-id="311aa-215">Draw-Aufrufinstancing</span><span class="sxs-lookup"><span data-stu-id="311aa-215">Draw call instancing</span></span>

<span data-ttu-id="311aa-216">Einer der häufigsten Fehler in Unity, der die Leistung verringert, ist das Klonen von Materialien zur Laufzeit.</span><span class="sxs-lookup"><span data-stu-id="311aa-216">One of the most common mistakes in Unity that reduces performance is cloning materials at runtime.</span></span> <span data-ttu-id="311aa-217">Wenn GameObjects dasselbe Material gemeinsam nutzen und/oder dasselbe Gitternetz sind, können sie *[](https://docs.unity3d.com/Manual/DrawCallBatching.html)* mit Techniken wie statischer Batchverarbeitung, *[](https://docs.unity3d.com/Manual/DrawCallBatching.html)* dynamischer Batchverarbeitung und GPU-Instanzion *[für](https://docs.unity3d.com/Manual/GPUInstancing.html)* einzelne Zeichnen-Aufrufe optimiert werden.</span><span class="sxs-lookup"><span data-stu-id="311aa-217">If GameObjects share the same material and/or are the same mesh, they can be optimized into single draw calls via techniques such as *[static batching](https://docs.unity3d.com/Manual/DrawCallBatching.html)*, *[dynamic batching](https://docs.unity3d.com/Manual/DrawCallBatching.html)*, and *[GPU Instancing](https://docs.unity3d.com/Manual/GPUInstancing.html)*.</span></span> <span data-ttu-id="311aa-218">Wenn Entwickler jedoch eigenschaften des Materials eines [Renderers](https://docs.unity3d.com/ScriptReference/Renderer-material.html) zur Laufzeit ändern, erstellt Unity eine Klonkopie des zugewiesenen Materials.</span><span class="sxs-lookup"><span data-stu-id="311aa-218">However, if developer's modify properties of a [Renderer's material](https://docs.unity3d.com/ScriptReference/Renderer-material.html) at runtime, Unity will create a clone copy of the assigned material.</span></span>

<span data-ttu-id="311aa-219">Wenn z. B. eine Szene 100 Würfel enthält, kann ein Entwickler jeder zur Laufzeit eine eindeutige Farbe zuweisen.</span><span class="sxs-lookup"><span data-stu-id="311aa-219">For example, if there are a 100 cubes in a scene, a developer may want to assign a unique color to each at runtime.</span></span> <span data-ttu-id="311aa-220">Durch den Zugriff [*auf renderer.material.color*](https://docs.unity3d.com/ScriptReference/Material-color.html) in C# erstellt Unity ein neues Material im Arbeitsspeicher für diesen bestimmten Renderer/GameObject.</span><span class="sxs-lookup"><span data-stu-id="311aa-220">The access of [*renderer.material.color*](https://docs.unity3d.com/ScriptReference/Material-color.html) in C# will make Unity create a new material in memory for this particular renderer/GameObject.</span></span> <span data-ttu-id="311aa-221">Jeder der 100 Cubes verfügt über ein eigenes Material und kann daher nicht zu einem Zeichnen-Aufruf zusammengeführt werden, sondern zu 100 Draw-Aufrufanforderungen von der CPU an die GPU.</span><span class="sxs-lookup"><span data-stu-id="311aa-221">Each of the 100 cubes will have its own material and thus they cannot be merged together into one draw call, but instead will become 100 draw call requests from the CPU to the GPU.</span></span>

<span data-ttu-id="311aa-222">Um dieses Hindernis zu überwinden und trotzdem eine eindeutige Farbe pro Cube zu zuweisen, sollten Entwickler [MaterialPropertyBlock nutzen.](https://docs.unity3d.com/ScriptReference/MaterialPropertyBlock.html)</span><span class="sxs-lookup"><span data-stu-id="311aa-222">To overcome this obstacle and still assign a unique color per cube, developers should leverage [MaterialPropertyBlock](https://docs.unity3d.com/ScriptReference/MaterialPropertyBlock.html).</span></span>

```c#
private PropertyBlock m_PropertyBlock ;
private Renderer myRenderer;

private void Start()
{
     myRenderer = GetComponent<Renderer>();
     m_PropertyBlock = new MaterialPropertyBlock();
}

private void ChangeColor()
{
    // Creates a copy of the material once for this renderer
    myRenderer.material.color = Color.red;

    // vs.

    // Retains instancing capability for renderer
    m_PropertyBlock.SetColor("_Color", Color.red);
    myRenderer.SetPropertyBlock(m_PropertyBlock);
}
```

## <a name="unity-performance-tools"></a><span data-ttu-id="311aa-223">Unity-Leistungstools</span><span class="sxs-lookup"><span data-stu-id="311aa-223">Unity performance tools</span></span>

<span data-ttu-id="311aa-224">Unity bietet hervorragende Leistungstools, die in den Editor integriert sind.</span><span class="sxs-lookup"><span data-stu-id="311aa-224">Unity provides great performance tools that are built into the editor.</span></span>

- [<span data-ttu-id="311aa-225">Unity Profiler</span><span class="sxs-lookup"><span data-stu-id="311aa-225">Unity Profiler</span></span>](https://docs.unity3d.com/Manual//Profiler.html)
- [<span data-ttu-id="311aa-226">Unity-Framedebugger</span><span class="sxs-lookup"><span data-stu-id="311aa-226">Unity Frame Debugger</span></span>](https://docs.unity3d.com/Manual/FrameDebugger.html)

<span data-ttu-id="311aa-227">Wenn Sie den ungefähren Leistungsabbruch zwischen einem Shader und einem anderen abschätzen, ist es hilfreich, jeden Shader zu kompilieren und die Anzahl der Vorgänge pro Shaderphase zu sehen.</span><span class="sxs-lookup"><span data-stu-id="311aa-227">If estimating the rough performance tradeoff between one shader and another, it is useful to compile each shader and view the number of operations per shader stage.</span></span> <span data-ttu-id="311aa-228">Wählen Sie hierzu ein [Shader-Objekt](https://docs.unity3d.com/Manual/class-Shader.html) aus, und klicken Sie auf die *Schaltfläche Code kompilieren und* anzeigen.</span><span class="sxs-lookup"><span data-stu-id="311aa-228">This can be done by selecting a [shader asset](https://docs.unity3d.com/Manual/class-Shader.html) and clicking the *Compile and show code* button.</span></span> <span data-ttu-id="311aa-229">Dadurch werden alle Shadervarianten kompiliert und Visual Studio mit den Ergebnissen geöffnet.</span><span class="sxs-lookup"><span data-stu-id="311aa-229">This will compile all the shader variants and open visual studio with the results.</span></span> <span data-ttu-id="311aa-230">Hinweis: Die erzeugten Statistikergebnisse können variieren, je nachdem, welche Features für Materialien aktiviert wurden, die den angegebenen Shader verwenden.</span><span class="sxs-lookup"><span data-stu-id="311aa-230">Note: The statistic results produced may vary depending on what features have been enabled on materials utilizing the given shader.</span></span> <span data-ttu-id="311aa-231">Unity kompiliert nur die Shadervarianten, die direkt im aktuellen Projekt verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="311aa-231">Unity will only compile the shader variants being directly used in the current project.</span></span>

<span data-ttu-id="311aa-232">Unity Standard-Shader-Statistikbeispiel</span><span class="sxs-lookup"><span data-stu-id="311aa-232">Unity Standard shader statistics example</span></span>

![Unity Standard Shader Statistics 1](../features/images/performance/UnityStandardShader-Stats.PNG)

<span data-ttu-id="311aa-234">MrTK Standard-Shaderstatistikbeispiel</span><span class="sxs-lookup"><span data-stu-id="311aa-234">MRTK Standard shader statistics example</span></span>

![MRTK Standard Shader Statistics 2](../features/images/performance/MRTKStandardShader-Stats.PNG)

## <a name="see-also"></a><span data-ttu-id="311aa-236">Weitere Informationen</span><span class="sxs-lookup"><span data-stu-id="311aa-236">See also</span></span>

### <a name="unity"></a><span data-ttu-id="311aa-237">Unity</span><span class="sxs-lookup"><span data-stu-id="311aa-237">Unity</span></span>

- [<span data-ttu-id="311aa-238">Unity-Leistungsoptimierung für Einsteiger</span><span class="sxs-lookup"><span data-stu-id="311aa-238">Unity Performance Optimization for Beginners</span></span>](https://www.youtube.com/watch?v=1e5WY2qf600)
- [<span data-ttu-id="311aa-239">Unity-Tutorials zur Leistungsoptimierung</span><span class="sxs-lookup"><span data-stu-id="311aa-239">Unity Performance Optimization Tutorials</span></span>](https://unity3d.com/learn/tutorials/topics/performance-optimization)
- [<span data-ttu-id="311aa-240">Bewährte Methoden für die Unity-Optimierung</span><span class="sxs-lookup"><span data-stu-id="311aa-240">Unity Optimization Best Practices</span></span>](https://docs.unity3d.com/Documentation/Manual/BestPracticeUnderstandingPerformanceInUnity.html)
- [<span data-ttu-id="311aa-241">Optimieren der Grafikleistung</span><span class="sxs-lookup"><span data-stu-id="311aa-241">Optimizing graphics performance</span></span>](https://docs.unity3d.com/Manual/OptimizingGraphicsPerformance.html)
- [<span data-ttu-id="311aa-242">Praktische Anleitung zur Optimierung mobiler Geräte</span><span class="sxs-lookup"><span data-stu-id="311aa-242">Mobile Optimization Practical Guide</span></span>](https://docs.unity3d.com/Manual/MobileOptimizationPracticalGuide.html)

### <a name="windows-mixed-reality"></a><span data-ttu-id="311aa-243">Windows Mixed Reality</span><span class="sxs-lookup"><span data-stu-id="311aa-243">Windows Mixed Reality</span></span>

- [<span data-ttu-id="311aa-244">Empfohlene Einstellungen für Unity</span><span class="sxs-lookup"><span data-stu-id="311aa-244">Recommended Settings for Unity</span></span>](/windows/mixed-reality/recommended-settings-for-unity)
- [<span data-ttu-id="311aa-245">Grundlegendes zur Leistung Mixed Reality</span><span class="sxs-lookup"><span data-stu-id="311aa-245">Understanding Performance for Mixed Reality</span></span>](/windows/mixed-reality/understanding-performance-for-mixed-reality)
- [<span data-ttu-id="311aa-246">Leistungsempfehlungen für Unity</span><span class="sxs-lookup"><span data-stu-id="311aa-246">Performance recommendations for Unity</span></span>](/windows/mixed-reality/performance-recommendations-for-unity)
- [<span data-ttu-id="311aa-247">Leitfaden zur Ereignisablaufverfolgung für Windows Unity</span><span class="sxs-lookup"><span data-stu-id="311aa-247">Event Tracing for Windows Unity Guide</span></span>](https://docs.unity3d.com/uploads/ExpertGuides/Analyzing_your_game_performance_using_Event_Tracing_for_Windows.pdf)

### <a name="oculus"></a><span data-ttu-id="311aa-248">Oculus</span><span class="sxs-lookup"><span data-stu-id="311aa-248">Oculus</span></span>

- [<span data-ttu-id="311aa-249">Leistungsrichtlinien</span><span class="sxs-lookup"><span data-stu-id="311aa-249">Performance Guidelines</span></span>](https://developer.oculus.com/documentation/pcsdk/latest/concepts/dg-performance-guidelines/)
- [<span data-ttu-id="311aa-250">Leistungstools</span><span class="sxs-lookup"><span data-stu-id="311aa-250">Performance Tools</span></span>](https://developer.oculus.com/documentation/pcsdk/latest/concepts/dg-performance-tools/)

### <a name="mesh-optimization"></a><span data-ttu-id="311aa-251">Mesh-Optimierung</span><span class="sxs-lookup"><span data-stu-id="311aa-251">Mesh optimization</span></span>

- [<span data-ttu-id="311aa-252">Optimieren von 3D-Modellen</span><span class="sxs-lookup"><span data-stu-id="311aa-252">Optimize 3D models</span></span>](/dynamics365/mixed-reality/import-tool/optimize-models#performance-targets)
- [<span data-ttu-id="311aa-253">Bewährte Methoden zum Konvertieren und Optimieren von 3D-Echtzeitmodellen</span><span class="sxs-lookup"><span data-stu-id="311aa-253">Best practices for converting and optimizing real-time 3D models</span></span>](/dynamics365/mixed-reality/import-tool/best-practices)
